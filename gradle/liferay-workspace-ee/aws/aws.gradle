/*
 * Copyright (c) 2000-present Liferay, Inc. All rights reserved.
 *
 * The contents of this file are subject to the terms of the Liferay Enterprise
 * Subscription License ("License"). You may not use this file except in
 * compliance with the License. You can obtain a copy of the License by
 * contacting Liferay, Inc. See the License for the specific language governing
 * permissions and limitations under the License, including but not limited to
 * distribution rights of the Software.
 */

import org.apache.tools.ant.filters.ReplaceTokens

def awsAmiBaseAmiLinuxPackagesFormat = gradle.liferayWorkspaceEe.awsAmiBaseAmiLinuxPackagesFormat

assert awsAmiBaseAmiLinuxPackagesFormat == 'deb' || awsAmiBaseAmiLinuxPackagesFormat == 'rpm',
        "Unknown Linux packages format, either 'deb' or 'rpm' has to be set " +
                "in 'liferay.workspace.ee.aws.ami.base.ami.linux.packages.format'"

def ospackageJdkInstallationType = gradle.liferayWorkspaceEe.ospackageJdkInstallationType

// possible tasks being used during AMI's build:
//  * distBundleDeb
//  * distBundleRpm
def distBundleOspackageTaskPath =
        ":liferay-workspace-ee:ospackage:distBundle${awsAmiBaseAmiLinuxPackagesFormat.capitalize()}"

def distBundleOspackageTask = tasks.getByPath(distBundleOspackageTaskPath)
assert distBundleOspackageTask != null,
        "Cannot find required task which produces the DEB / RPM file (checked path '${distBundleOspackageTaskPath}', " +
                "based on configured base ami linux packaging format '${awsAmiBaseAmiLinuxPackagesFormat}')"

ext {
    // RPM / DEB task will output one .rpm / .deb file, but possibly others as
    // well (like 'sample-liferay-dxp-workspace.dev_1.0.0-11_amd64.changes')
    distBundleOspackageTaskOutputPackageFile =
            distBundleOspackageTask.outputs.files.findAll { it.name.endsWith('.deb') || it.name.endsWith('.rpm')}[0]

    currentEnvironment = gradle.liferayWorkspace.getEnvironment()

    projectVersion = gradle.liferayWorkspaceEe.projectVersion

    releaseNumber = gradle.liferayWorkspaceEe.releaseNumber

    packerExecutable = gradle.liferayWorkspaceEe.externalExecutables.packer.executable
}

task distBundleAmi {
    group "Liferay Workspace EE - AWS"
    description "Creates new AMI in AWS, with Liferay bundle installed using ${awsAmiBaseAmiLinuxPackagesFormat.toUpperCase()}."

    dependsOn 'runPackerBuild', distBundleOspackageTask

    doLast {
        def amiName = runPackerBuild.packerUserVariables['ami_name']

        def packerOutputFile = runPackerBuild.outputFile

        def amiIdsByRegion = _parseMachineOutputForCreatedAmiIds(packerOutputFile)

        println "New AMI(s) with '${rootProject.relativePath(distBundleOspackageTaskOutputPackageFile)}' " +
                "package installed was baked in AWS. Following AMIs were created:"

        amiIdsByRegion.each { key, value ->
            println "  * ${key}: ${value}"
        }

        println ''

        // create artifacts = text files in '[root]/build/' with just AMI ID inside

        _createArtifactsFromAmisIds(amiIdsByRegion, amiName)
    }
}

task listAwsProperties() {
    group "Liferay Workspace EE - AWS"
    description "Lists all variables as used by AWS-related tasks"

    doLast {
        println "AWS variables being utilized:"

        gradle.liferayWorkspaceEe.findAll { it.key.startsWith('aws') }.each { String key, String value ->
            def printedValue = key == ('awsSecretKey') ? _sanitizeSecret(value) : value

            println "  ${key} = ${printedValue}"
        }
    }
}

// Include the file after the main tasks were defined
apply from: 'aws.cleanup.gradle'

///////////////////
// Internal Tasks
///////////////////

task buildPackerTemplate(type: Copy) {

    List<String> extrasFilePaths = gradle.liferayWorkspaceEe.awsAmiPackerExtraProvisionersJsonFiles

    List<String> allProvisionersJsonObjects = extrasFilePaths.collect { String extrasFilePath ->
        // get the file's contents or default to empty JSON array
        String extraProvisionersJsonArray = extrasFilePath ? rootProject.file(extrasFilePath).text.trim() : '[]'

        // validate the extras JSON before it gets inserted into Packer template

        try {
            def json = new groovy.json.JsonSlurper().parseText(extraProvisionersJsonArray)

            assert json instanceof List, "No JSON array on the top-level"
        } catch (Throwable e){
              throw new InvalidUserDataException(
                      "Please make sure the content of '${extrasFilePath}' is a valid JSON array " +
                              "with extra Packer provisioner objects inside: \n\n" +
                              "${e.message ?: e}",
                      e)
        }

        // trim the leading '[' and trailing ']' - we'll need just the inner JSON objects
        def extraProvisionersJsonObjects =
                extraProvisionersJsonArray.substring(1, extraProvisionersJsonArray.length() - 1).trim()

        return extraProvisionersJsonObjects
    }

    from 'packer-template.groovy-template.json'
    into buildDir

    rename 'packer-template.groovy-template.json', 'packer-template.json'

    filter(
            ReplaceTokens,
            tokens: [
                    // if there are some extra provisioners' JSON object to append,
                    // do so after a comma on new line with some indent
                    EXTRA_PROVISIONERS_CONTENT :
                            allProvisionersJsonObjects.collect { ",\n    ${it}" }.join('')
            ].collectEntries { k,v -> [ k as String, v as String ] }
    )

    ext.builtPackerTemplate = "${buildDir}/packer-template.json"
}

task runPackerBuild (type: AwsPackerExec) {
    dependsOn distBundleOspackageTask, 'runPackerValidate', buildPackerTemplate

    ext.packerUserVariables = [
            // use the name of the DEB / RPM file will be the name of the AMI + platform + timestamp
            ami_name                       :
                    "${distBundleOspackageTaskOutputPackageFile.name}/" +
                    "${gradle.liferayWorkspaceEe.awsAmiPlatformKey}/" +
                    "${System.currentTimeSeconds()}",

            ami_description                :
                    "Built for project '${rootProject.name}', '${currentEnvironment}' environment, " +
                    "version '${projectVersion}', release number '${releaseNumber}', on ${new Date()}",

            ami_primary_region             : gradle.liferayWorkspaceEe.awsAmiPrimaryRegion,
            ami_copy_to_regions            : gradle.liferayWorkspaceEe.awsAmiCopyToRegions.join(','),

            base_ami_id                    : gradle.liferayWorkspaceEe.awsAmiBaseAmiId,
            base_ami_linux_packages_format : gradle.liferayWorkspaceEe.awsAmiBaseAmiLinuxPackagesFormat,
            base_ami_ssh_user_name         : gradle.liferayWorkspaceEe.awsAmiBaseAmiSshUserName,

            instance_type                  : gradle.liferayWorkspaceEe.awsAmiBuildEc2InstanceType,
            vpc_id                         : gradle.liferayWorkspaceEe.awsAmiBuildEc2InstanceVpcId,
            subnet_id                      : gradle.liferayWorkspaceEe.awsAmiBuildEc2SubnetId,
            iam_instance_profile           : gradle.liferayWorkspaceEe.awsAmiBuildIamInstanceProfile,

            liferay_bundle_ospackage_source: distBundleOspackageTaskOutputPackageFile.absolutePath,
            liferay_bundle_ospackage_name  : distBundleOspackageTaskOutputPackageFile.name,

            // TODO any chance to compute the value in the execution phase (not in config phase as here),
            // based on the actual size of the .deb file?
            liferay_bundle_ospackage_size  : '400-1100 MB',

            project_name                   : rootProject.name,
            project_version                : projectVersion,
            project_environment_name       : currentEnvironment,
            project_release_number         : releaseNumber,

            // the variables potentially useful to extra provisioners
            WORKSPACE_ROOT_DIR             : rootProject.projectDir.absolutePath
    ]

    // Pass all EE properties as GRADLE_{key}: {value} to Packer
    //
    // When some EE property is not set explicitly for a Gradle run, the default
    // is read from 'gradle.workspace-ee-defaults.properties' and set on the root project,
    // see 'gradle/liferay-workspace-ee/liferay-workspace-ee.gradle'
    //
    // NOTE: workspace (non-EE) properties defaults are not set this way.

    // Allow any to be forwarded, so that project-specific provisioners can configure
    // itself through Gradle
    // exclude 'properties', since that would again contain all the properties and the value would be very long
    def forwardedProperties = rootProject.properties.findAll { it.key != 'properties' }
    packerUserVariables.putAll(
            forwardedProperties.collectEntries { k, v -> [ "GRADLE_${k}", v ]}
    )

    ext.packerEnvironmentVariables = [
            AWS_ACCESS_KEY_ID    : gradle.liferayWorkspaceEe.awsAccessKey,
            AWS_SECRET_ACCESS_KEY: gradle.liferayWorkspaceEe.awsSecretKey
    ]

    ext.outputFile = new File(project.buildDir, "packer.out.txt")

    // AWS credentials are passed explicitly to the Packer template, see
    // https://www.packer.io/docs/builders/amazon.html

    def showExtraPackerLogging = false

    // must be machine-readable since we want to parse created AMI IDs from Packer output
    // see task 'distBundleAmi' -> doLast
    def machineReadableOutput = true

    packerCommand(
            packerExecutable,
            buildPackerTemplate.builtPackerTemplate,
            'build',
            packerUserVariables,
            packerEnvironmentVariables,
            showExtraPackerLogging,
            machineReadableOutput)


    doFirst {
        outputFile.parentFile.mkdirs()

        // store the standard output simultaneously into a file as well
        // based on: http://stackoverflow.com/a/27053294/4966203
        standardOutput = new org.apache.tools.ant.util.TeeOutputStream(
                new FileOutputStream(outputFile),
                System.out);
    }
}

task runPackerValidate (type: AwsPackerExec) {
    dependsOn distBundleOspackageTask, buildPackerTemplate

    def showExtraPackerLogging = false

    // for validation, use human-readable output
    def machineReadableOutput = false

    packerCommand(
            packerExecutable,
            buildPackerTemplate.builtPackerTemplate,
            'validate',
            runPackerBuild.packerUserVariables,
            runPackerBuild.packerEnvironmentVariables,
            showExtraPackerLogging,
            machineReadableOutput)

    doFirst {
        println "Used Packer user variables:"

        runPackerBuild.packerUserVariables.each { key, value ->
            println "  ${key} = ${value}"
        }

        println ''

        println "Used environment variables:"

        runPackerBuild.packerEnvironmentVariables.each { String key, String value ->
            def printedValue = key == ('AWS_SECRET_ACCESS_KEY') ? _sanitizeSecret(value) : value

            println "  ${key} = ${printedValue}"
        }

        println ''
    }
}

/**
 * Sanitized value with a secret content. If empty of null, returns empty or null.
 *
 * If too short, returns *** (the count of asterisks is based on the length), to confirm
 * at lest the size of the value. Otherwise beginning and end will be printed out, with ***
 * in the middle (same for all lengths).
 * 
 * @param value
 * @return
 */
private String _sanitizeSecret(String value) {
    return value?.length() >= 15 ?
            "${value.substring(0, 3)}***${value.substring(value.length() - 3)}" :
            '*'.multiply(value ? value.length() : 0)
}

/**
 * Takes machine output from Packer and tries to parse the AMI IDs from it, which were created.
 * @param packerOutput
 * 
 * @return amiIdsByRegion the map of amis, like: {@code [ 'us-east-1: 'ami-1234', 'eu-west-2: 'ami-5678' ... ]}
 */
private Map<String, String> _parseMachineOutputForCreatedAmiIds(File packerOutputFile) {

    assert packerOutputFile, "Packer output file has to be provided"

    // standard output:
    //
    //    ...
    //    --> amazon-ebs: AMIs were created:
    //
    //    us-east-1: ami-19601070
    //    us-west-2: ami-dfrwe345

    // machine readable output (based on https://github.com/mitchellh/packer/issues/881):
//    ...
//    1393030721,amazon-ebs,artifact-count,1
//    1393030721,amazon-ebs,artifact,0,builder-id,mitchellh.amazonebs
//    1393030721,amazon-ebs,artifact,0,id,us-east-1:ami-e31e1f8a%!(PACKER_COMMA)us-west-1:ami-c4fac681

    def packerOutput = packerOutputFile.text

    String line = packerOutput.find(/artifact,0,id,.*/)

    logger.debug "_parseMachineOutputForCreatedAmiIds: line: ${line}"

    if (line) {
        def mapping = line.replace('artifact,0,id,', '')

        logger.debug "_parseMachineOutputForCreatedAmiIds: mapping: ${mapping}"

        def amis = mapping.tokenize('%!(PACKER_COMMA)')

        logger.debug "_parseMachineOutputForCreatedAmiIds: amis: ${amis}"

        return amis.collectEntries {
            def keyValue = it.split(':');
            [keyValue[0], keyValue[1]]
        }
    }
    else { // 'artifact,0,id,.*' not matched in the output

        logger.quiet "Could not parse the Packer output for created AMIs, is the output machine-readable? " +
                "Output written into '${packerOutputFile.absolutePath}' for debug purposes"

        return [:]
    }
}

/**
 * Takes mapping of AMIs and for each creates one text file in [rootProject]/build
 * with AMI ID written  inside. Also creates one comprehensive properteis file (ami-ids.properties)
 *
 * Useful when e.g. related Jenkins job want to use product of 'distBundleAmi' and parse it.
 *
 * @param amiIdsByRegion
 * @param amiName
 */
private void _createArtifactsFromAmisIds(Map<String, String> amiIdsByRegion, String amiName) {
    assert amiIdsByRegion != null   // can be empty
    assert amiName

    def targetDir = rootProject.buildDir
    targetDir.mkdirs()

    // replace all characters (allowed in the AMI name) which are not allowed in file names
    // typical AMI name: "sample-liferay-dxp-workspace.dev_1.0.0-4_amd64.deb/ubuntu/1473166230187"
    def fileBaseName = amiName.replaceAll(/[^a-z0-9\._-]/, '-')

    // create comprehensive file, with Linux shell-valid variables:
    //      AMI_US_EAST_1=ami-1234
    //      AMI_EU_WEST_2=ami-5678
    
    def allAmiIdsPropertiesFile = new File(targetDir, "ami-ids.properties")

    amiIdsByRegion.each { awsRegion, amiId ->
        def artifactsForAmiInOneRegion = new File(targetDir, "${fileBaseName}.${awsRegion}.ami-id.txt")

        artifactsForAmiInOneRegion << amiId

        logger.info "Written artifact file with AMI ID inside: '$artifactsForAmiInOneRegion.absolutePath'."

        allAmiIdsPropertiesFile << "AMI_${awsRegion.toUpperCase().replace('-', '_')}=${amiId}\n"
    }

    logger.quiet "All AMI IDs were written into '${rootProject.relativePath(allAmiIdsPropertiesFile)}' " +
                    "+ one by one into files like '*.{region}.ami-id.txt'"
}

/**
 * Executes Packer (https://www.packer) 'build' command with given JSON config and
 * given set of user variables. The result is the same as if you run e.g.:
 *
 *      $ packer build \
 *          -var 'aws_access_key=YOUR ACCESS KEY' \
 *          -var 'aws_secret_key=YOUR SECRET KEY' \
 *          packer-template.json
 */
class AwsPackerExec extends Exec {

    void packerCommand(
            String packerExecutable, String packerTemplate, String packerCommand,
            Map packerUserVariables, Map packerEnvironmentVariables = [:],
            boolean showExtraPackerLogging = false,
            boolean machineReadableOutput = true) {

        // use environment variables, so that the values are not visible in process'
        // command line; environment variables are explicitly used in the Packer template
        environment(packerEnvironmentVariables)

        if (showExtraPackerLogging) {
            environment([ PACKER_LOG: 1 ])
        }

        def packerArguments = [ packerCommand ]

        if (packerCommand == 'build') {
            // based on: http://stackoverflow.com/a/43365458/4966203
            if (project.gradle.startParameter.logLevel.name() in [ 'DEBUG', 'INFO' ]) {
                // Gradle was started with '--debug' or '--info' => run Packer in debug mode
                //          to get detailed logging and stacktraces in case of failure

                // This will make sure to show extra info + write the keypair file into working directory
                packerArguments.add '-debug'
            }
        }

        if (machineReadableOutput) {
            packerArguments.add '-machine-readable'
        }

        packerUserVariables.each { key, value ->
            packerArguments.add '-var'
            packerArguments.add "${key}=${value}"
        }

        packerArguments.add packerTemplate

        executable packerExecutable
        args packerArguments
    }

}